#pragma once

#include "decls.hpp"
#include <map>

inline namespace euler
{
/// Elements of R[T], the free R-algebra generated by the monoid (T, BinaryOp).
template <typename T, typename R = int64_t, std::invocable<T, T> auto BinaryOp = std::plus{}, auto identity = 0,
          template <typename...> class Map = std::map>
class Algebra
{
    Map<T, R> _m;

  public:
    using map_type = Map<T, R>;

    Algebra() = default;
    constexpr Algebra(map_type m) : _m(std::move(m)) { normalize(); }
    constexpr Algebra(R r) : _m({{identity, std::move(r)}}) {}

    /// The basis element [t].
    constexpr static Algebra basis(T t) { return {{{std::move(t), 1}}}; }
    /// The multiplicaitve identity.
    constexpr static Algebra zero() { return {}; }
    /// The multiplicaitve identity.
    constexpr static Algebra one() { return {{{identity, 1}}}; }

    [[nodiscard]] const map_type &data() const { return _m; }

    void normalize()
    {
        erase_if(_m, [](auto &&x) { return x.second == 0; });
    }

    constexpr R operator[](T t)
    {
        if (auto it = _m.find(t); it != _m.end())
            return it->second;
        return 0;
    }

    template <typename Self> constexpr Self &&operator+=(this Self &&self, const Self &other)
    {
        for (auto &&[t, r] : other._m)
        {
            auto it = self._m.find(t);
            if (it == self._m.end())
                self._m[t] = r;
            else if (it->second == -r)
                self._m.erase(it);
            else
                it->second += r;
        }
        return std::forward<Self>(self);
    }
    template <typename Self> constexpr Self operator+(this Self self, const Self &other)
    {
        return Self{std::move(self)} += other;
    }

    template <typename Self> constexpr Self &&operator-=(this Self &&self, const Self &other)
    {
        for (auto &&[t, r] : other._m)
        {
            auto it = self._m.find(t);
            if (it == self._m.end())
                self._m[t] = -r;
            else if (it->second == r)
                self._m.erase(it);
            else
                it->second -= r;
        }
        return std::forward<Self>(self);
    }
    template <typename Self> constexpr Self operator-(this Self self, const Self &other)
    {
        return Self{std::move(self)} -= other;
    }

    constexpr Algebra operator*(const Algebra &other) const
    {
        map_type m{};
        for (auto &&[t1, r1] : _m)
            for (auto &&[t2, r2] : other._m)
                m[BinaryOp(t1, t2)] += r1 * r2;
        return {m};
    }
    constexpr Algebra &operator*=(const Algebra &other) { return *this = *this * other; }

    constexpr Algebra operator-() const
    {
        map_type m{};
        for (auto &&[t, r] : _m)
            m[t] = -r;
        return {m};
    }

    constexpr bool operator==(const Algebra &other) const { return _m == other._m; }
    constexpr bool operator!=(const Algebra &other) const { return _m != other._m; }

    /// Returns the modular exponentiation of this number.
    template <typename Self, integral2 U> [[nodiscard]] constexpr Self pow(this Self &&self, U exponent)
    {
        using A = std::decay_t<Self>;
        assert(exponent >= 0);
        if (exponent == 0)
            return A::one();
        A x = A::one();
        A y = std::forward<Self>(self);
        while (true)
        {
            if (exponent & 1)
            {
                x *= y;
                if (exponent == 1)
                    break;
            }
            exponent >>= 1;
            y *= y;
        }
        return x;
    }

    [[nodiscard]] constexpr std::string str() const
    {
        std::stringstream ss;
        for (auto it = _m.begin(); it != _m.end(); ++it)
        {
            auto &&[t, r] = *it;
            if (it != _m.begin())
                ss << " + ";
            if (r != 1)
                ss << r;
            ss << '[' << t << ']';
        }
        return std::move(ss).str();
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator<<(std::basic_ostream<CharT, Traits> &o, const Algebra &x)
    {
        return o << x.str();
    }
};

// Overrides multiplication with truncation.
template <typename T, typename R = int64_t, int64_t Precision = 30, std::invocable<T, T> auto BinaryOp = std::plus{},
          auto identity = 0, template <typename...> class Map = std::map>
class PowerSeries : public Algebra<T, R, BinaryOp, identity, Map>
{
  public:
    using map_type = Map<T, R>;

    PowerSeries() = default;
    constexpr PowerSeries(map_type m) : Algebra<T, R, BinaryOp, identity, Map>(std::move(m)) {}
    constexpr PowerSeries(R r) : Algebra<T, R, BinaryOp, identity, Map>({{identity, std::move(r)}}) {}

    /// The basis element [t].
    constexpr static PowerSeries basis(T t) { return {{{std::move(t), 1}}}; }
    /// The multiplicaitve identity.
    constexpr static PowerSeries zero() { return {}; }
    /// The multiplicaitve identity.
    constexpr static PowerSeries one() { return {{{identity, 1}}}; }

    constexpr PowerSeries operator*(const PowerSeries &other) const
    {
        map_type m{};
        for (auto &&[t1, r1] : this->data())
            for (auto &&[t2, r2] : other.data())
            {
                auto t = BinaryOp(t1, t2);
                if (t <= Precision)
                    m[t] += r1 * r2;
            }
        return {m};
    }
    constexpr PowerSeries &operator*=(const PowerSeries &other) { return *this = *this * other; }
};
} // namespace euler
